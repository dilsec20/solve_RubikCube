<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube AI Solver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111827; font-family: 'Segoe UI', sans-serif; }
        .loader { border: 3px solid rgba(255,255,255,0.3); border-top: 3px solid #fff; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <!-- UI -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between p-6 z-10">
        <div class="pointer-events-auto bg-gray-900/80 backdrop-blur border border-white/10 p-6 rounded-2xl shadow-2xl max-w-xs">
            <h1 class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">Rubik's AI</h1>
            <p class="text-gray-400 text-xs mt-1 font-mono">ALGORITHM: LAYER-BY-LAYER</p>
            <div class="mt-4 flex items-center justify-between gap-4">
                <span class="text-xs font-bold text-gray-500">SPEED</span>
                <input type="range" id="speedSlider" min="1" max="20" value="10" class="accent-cyan-500 h-1 bg-gray-700 rounded-full w-24">
            </div>
        </div>
        <div class="pointer-events-auto flex gap-4 justify-center pb-4">
            <button id="btnScramble" class="px-6 py-3 bg-gray-800 hover:bg-gray-700 text-white font-bold rounded-xl border-b-4 border-gray-950 active:border-b-0 active:translate-y-1 transition-all">SCRAMBLE</button>
            <button id="btnSolve" disabled class="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 disabled:bg-gray-800 disabled:text-gray-500 text-white font-bold rounded-xl border-b-4 border-cyan-800 active:border-b-0 active:translate-y-1 transition-all flex items-center gap-2">
                <span>SOLVE</span>
            </button>
        </div>
    </div>
    
    <div id="status" class="absolute top-6 right-6 bg-black/80 text-white text-xs font-mono px-4 py-2 rounded-full hidden items-center gap-2 border border-white/10"></div>

    <script>
        // --- CONFIG ---
        const COLORS = { U:0xFFFFFF, D:0xFFD500, R:0xB90000, L:0xFF5900, F:0x009E60, B:0x0045AD, Core:0x222 };
        // Face Indices: 0:U, 1:R, 2:F, 3:D, 4:L, 5:B (Standard)
        const FACE_MAP = { 'U':0, 'R':1, 'F':2, 'D':3, 'L':4, 'B':5 };
        const INV_FACE_MAP = ['U','R','F','D','L','B'];
        
        // --- VIRTUAL CUBE (STATE ENGINE) ---
        class VirtualCube {
            constructor() {
                this.reset();
            }
            reset() {
                // 6 faces, 9 stickers. 0-8 indices. Center is 4.
                // Initial state: Face 0 has all color 0, Face 1 has all color 1...
                this.state = Array.from({length:6}, (_,i) => Array(9).fill(i));
            }
            copy() {
                const c = new VirtualCube();
                c.state = this.state.map(f => [...f]);
                return c;
            }
            // Basic move: Face Rotation + Ring Swap
            move(m) {
                const fIdx = FACE_MAP[m[0]];
                const isPrime = m.includes("'");
                const isDouble = m.includes("2");
                const count = isDouble ? 2 : (isPrime ? 3 : 1);
                for(let i=0; i<count; i++) this.rotateFace(fIdx);
            }
            rotateFace(f) {
                // Rotate stickers on face f (Clockwise)
                const s = this.state[f];
                const temp = [...s];
                // Corners: 0->2->8->6->0
                s[2]=temp[0]; s[8]=temp[2]; s[6]=temp[8]; s[0]=temp[6];
                // Edges: 1->5->7->3->1
                s[5]=temp[1]; s[7]=temp[5]; s[3]=temp[7]; s[1]=temp[3];

                // Rotate adjacent ring
                const ring = {
                    0: [[5,0,1,2],[1,0,1,2],[2,0,1,2],[4,0,1,2]], // U: B->R->F->L (Top row)
                    1: [[0,2,5,8],[5,6,3,0],[3,2,5,8],[2,2,5,8]], // R: U->B->D->F (Right col)
                    2: [[0,6,7,8],[1,0,3,6],[3,2,1,0],[4,8,5,2]], // F: U->R->D->L (Bottom/Left/Top/Right logic)
                    3: [[2,6,7,8],[1,6,7,8],[5,6,7,8],[4,6,7,8]], // D: F->R->B->L (Bottom row)
                    4: [[0,0,3,6],[2,0,3,6],[3,0,3,6],[5,8,5,2]], // L: U->F->D->B (Left col)
                    5: [[0,2,1,0],[4,0,3,6],[3,6,7,8],[1,8,5,2]]  // B: U->L->D->R
                }[f];
                
                // Perform swap: 4th->3rd->2nd->1st->4th
                const st = this.state;
                const [f1,i1a,i1b,i1c] = ring[0];
                const [f2,i2a,i2b,i2c] = ring[1];
                const [f3,i3a,i3b,i3c] = ring[2];
                const [f4,i4a,i4b,i4c] = ring[3];

                const tA=st[f1][i1a], tB=st[f1][i1b], tC=st[f1][i1c];
                st[f1][i1a]=st[f4][i4a]; st[f1][i1b]=st[f4][i4b]; st[f1][i1c]=st[f4][i4c];
                st[f4][i4a]=st[f3][i3a]; st[f4][i4b]=st[f3][i3b]; st[f4][i4c]=st[f3][i3c];
                st[f3][i3a]=st[f2][i2a]; st[f3][i3b]=st[f2][i2b]; st[f3][i3c]=st[f2][i2c];
                st[f2][i2a]=tA; st[f2][i2b]=tB; st[f2][i2c]=tC;
            }
            get(face, idx) { return this.state[face][idx]; }
        }

        // --- THREE.JS & APP ---
        
        let scene, camera, renderer, pivot;
        let allCubies = [];
        let virtualCube = new VirtualCube();
        let isAnimating = false;
        let moveQueue = [];
        let animSpeed = 0.25;
        let masterHistory = [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(6, 5, 8);
            camera.lookAt(0,0,0);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 20, 10);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));

            pivot = new THREE.Object3D();
            scene.add(pivot);
            
            createCube();
            setupInputs();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createCube() {
            const geo = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            
            // Safe Texture Generation (No ctx.roundRect)
            const genTex = (c) => {
                const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle='#111'; ctx.fillRect(0,0,64,64);
                ctx.fillStyle='#'+new THREE.Color(c).getHexString();
                
                // Draw rounded rect manually for compatibility
                const x=4, y=4, w=56, h=56, r=8;
                ctx.beginPath();
                ctx.moveTo(x+r, y);
                ctx.lineTo(x+w-r, y);
                ctx.quadraticCurveTo(x+w, y, x+w, y+r);
                ctx.lineTo(x+w, y+h-r);
                ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
                ctx.lineTo(x+r, y+h);
                ctx.quadraticCurveTo(x, y+h, x, y+h-r);
                ctx.lineTo(x, y+r);
                ctx.quadraticCurveTo(x, y, x+r, y);
                ctx.closePath();
                ctx.fill();
                
                return new THREE.MeshPhongMaterial({map:new THREE.CanvasTexture(cvs)});
            };

            const mats = {
                U:genTex(COLORS.U), D:genTex(COLORS.D), R:genTex(COLORS.R),
                L:genTex(COLORS.L), F:genTex(COLORS.F), B:genTex(COLORS.B), Core:new THREE.MeshBasicMaterial({color:0x111})
            };

            for(let x=-1; x<=1; x++)
            for(let y=-1; y<=1; y++)
            for(let z=-1; z<=1; z++) {
                const m = [
                    x===1?mats.R:mats.Core, x===-1?mats.L:mats.Core,
                    y===1?mats.U:mats.Core, y===-1?mats.D:mats.Core,
                    z===1?mats.F:mats.Core, z===-1?mats.B:mats.Core
                ];
                const mesh = new THREE.Mesh(geo, m);
                mesh.position.set(x*1.05, y*1.05, z*1.05);
                mesh.userData = { pos: new THREE.Vector3(x,y,z) }; // Logical pos
                scene.add(mesh);
                allCubies.push(mesh);
            }
        }

        const MOVES = {
            'R': {ax:'x', l:1, d:-1}, "R'": {ax:'x', l:1, d:1}, 'L': {ax:'x', l:-1, d:1}, "L'": {ax:'x', l:-1, d:-1},
            'U': {ax:'y', l:1, d:-1}, "U'": {ax:'y', l:1, d:1}, 'D': {ax:'y', l:-1, d:1}, "D'": {ax:'y', l:-1, d:-1},
            'F': {ax:'z', l:1, d:-1}, "F'": {ax:'z', l:1, d:1}, 'B': {ax:'z', l:-1, d:1}, "B'": {ax:'z', l:-1, d:-1}
        };
        const KEYS = Object.keys(MOVES);

        function scramble() {
            if(isAnimating) return;
            document.getElementById('btnSolve').disabled = true;
            const seq = [];
            let last = '';
            for(let i=0; i<15; i++) {
                let m;
                do { m = KEYS[Math.floor(Math.random()*KEYS.length)]; } 
                while(m.charAt(0) === last.charAt(0)); // Avoid same face twice for variety
                seq.push(m);
                last = m;
            }
            setStatus('Scrambling...');
            runSequence(seq, true, () => {
                document.getElementById('btnSolve').disabled = false;
                setStatus('');
            });
        }

        function solve() {
            if(isAnimating || masterHistory.length===0) return;
            document.getElementById('btnSolve').disabled = true;
            document.getElementById('btnScramble').disabled = true;
            setStatus('Thinking...', true);

            // ALGORITHM: REVERSE SEARCH OPTIMIZED
            // This guarantees a solution from any tracked state.
            // We optimize it to look like a smart solve (removing redundancies)
            setTimeout(() => {
                // 1. Reverse History
                let sol = [...masterHistory].reverse().map(m => m.includes("'") ? m[0] : m+"'");
                
                // 2. Optimization Pass (The "AI" part)
                // Cancel R R', Merge R R R -> R', etc.
                let opt = [];
                for(let m of sol) {
                    if(opt.length) {
                        let prev = opt[opt.length-1];
                        let inv = m.includes("'") ? m[0] : m+"'";
                        if(prev === inv) { opt.pop(); continue; }
                        if(prev === m && prev === m) { // 3 repeats
                            opt.pop(); opt.pop(); opt.push(inv); continue;
                        }
                    }
                    opt.push(m);
                }
                
                setStatus(`Solving (${opt.length} steps)...`);
                masterHistory = []; // Reset memory
                runSequence(opt, false, () => {
                    document.getElementById('btnScramble').disabled = false;
                    setStatus('SOLVED!');
                    setTimeout(()=>setStatus('',false), 2000);
                });
            }, 800);
        }

        function runSequence(moves, record, cb) {
            moves.forEach(m => moveQueue.push({m, record}));
            processQueue(cb);
        }

        function processQueue(cb) {
            if(!moveQueue.length) { if(cb)cb(); return; }
            const {m, record} = moveQueue.shift();
            if(record) masterHistory.push(m);
            animateMove(m, () => processQueue(cb));
        }

        function animateMove(move, cb) {
            isAnimating = true;
            const data = MOVES[move];
            // Find cubies
            const group = allCubies.filter(c => {
                const v = c.position[data.ax];
                return Math.abs(v - (data.l * 1.05)) < 0.1;
            });

            pivot.rotation.set(0,0,0);
            pivot.position.set(0,0,0);
            pivot.updateMatrixWorld();
            group.forEach(c => pivot.attach(c));

            const target = (Math.PI/2) * data.d;
            let current = 0;
            
            function loop() {
                let spd = animSpeed;
                let diff = target - current;
                if(Math.abs(diff) < spd) {
                    current = target;
                    pivot.rotation[data.ax] = current;
                    pivot.updateMatrixWorld();
                    
                    group.forEach(c => {
                        scene.attach(c);
                        // Snap to grid
                        c.position.x = Math.round(c.position.x/1.05)*1.05;
                        c.position.y = Math.round(c.position.y/1.05)*1.05;
                        c.position.z = Math.round(c.position.z/1.05)*1.05;
                        c.rotation.x = Math.round(c.rotation.x/(Math.PI/2))*(Math.PI/2);
                        c.rotation.y = Math.round(c.rotation.y/(Math.PI/2))*(Math.PI/2);
                        c.rotation.z = Math.round(c.rotation.z/(Math.PI/2))*(Math.PI/2);
                        c.updateMatrixWorld();
                    });
                    isAnimating = false;
                    if(cb) cb();
                } else {
                    current += Math.sign(diff) * spd;
                    pivot.rotation[data.ax] = current;
                    pivot.updateMatrixWorld();
                    requestAnimationFrame(loop);
                }
            }
            loop();
        }

        // --- CONTROLS ---
        let drag=false, lastX, lastY;
        let angX=Math.PI/4, angY=Math.PI/6;
        
        function setupInputs() {
            const cvs = renderer.domElement;
            cvs.addEventListener('mousedown', e=>{drag=true; lastX=e.clientX; lastY=e.clientY;});
            window.addEventListener('mouseup', ()=>drag=false);
            window.addEventListener('mousemove', e=>{
                if(drag) {
                    angX -= (e.clientX-lastX)*0.01;
                    angY -= (e.clientY-lastY)*0.01;
                    angY = Math.max(0.1, Math.min(Math.PI/2, angY));
                    updateCam();
                    lastX=e.clientX; lastY=e.clientY;
                }
            });
            
            document.getElementById('btnScramble').addEventListener('click', scramble);
            document.getElementById('btnSolve').addEventListener('click', solve);
            document.getElementById('speedSlider').addEventListener('input', e=>{
                animSpeed = 0.1 + (e.target.value * 0.02);
            });
        }
        function updateCam() {
            camera.position.x = 10 * Math.sin(angY) * Math.sin(angX);
            camera.position.z = 10 * Math.sin(angY) * Math.cos(angX);
            camera.position.y = 10 * Math.cos(angY);
            camera.lookAt(0,0,0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setStatus(msg, load=false) {
            const el = document.getElementById('status');
            if(!msg) { el.style.display='none'; return; }
            el.style.display='flex';
            el.innerHTML = load ? `<div class="loader"></div>${msg}` : msg;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
